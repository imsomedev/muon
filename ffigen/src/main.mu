:version string = "0.3.0"

main() {
	enableCrashHandler()

	::currentAllocator = Memory.newArenaAllocator(1024 * 1024 * 1024)
	
	errors := new List<CommandLineArgsParserError>{}
	parser := new CommandLineArgsParser.from(Environment.getCommandLineArgs(), errors)
	args := parseArgs(parser)

	if errors.count > 0 {
		info := parser.getCommandLineInfo()
		for errors {
			Stderr.writeLine(CommandLineArgsParser.getErrorDesc(it, info))
		}
		exit(1)
	}

	rulesText := readFile(args.rulesPath, "Could not read rules file")
	ruleErrors := new List<RuleParseError>{}
	rules := parseRules(rulesText, ruleErrors)
	if ruleErrors.count > 0 {
		for e in ruleErrors {
			Stderr.writeLine(format("{}\n-> {}:{}", e.text, args.rulesPath, e.line))
		}
		exit(1)
	}

	sourceText := readFile(args.sourcePath, "Could not read source file")
	clangArgs := new Array<cstring>(args.clangArgs.count)
	for it, i in args.clangArgs {
		clangArgs[i] = it.alloc_cstring()
	}

	unit := parseCFile(args.sourcePath, getDiscoverySourceText(sourceText), clangArgs)
	numDiagnostics := clang_getNumDiagnostics(unit)
	if numDiagnostics > 0 {
		Stderr.writeLine(format("clang compilation failed:"))
		for i := 0_u; i < numDiagnostics {
			diag := clang_getDiagnostic(unit, i)
			Stderr.writeLine(diagnosticToString(diag))
		}
		exit(1)
	}

	state := new AppState { 
		clangTranslationUnit: unit,
		isPlatformAgnostic: args.isPlatformAgnostic,
		collisionCheck: args.collisionCheck,
		symbols: new Map.create<string, Sym>(),
		anonymousStructs: new Set.create<CXType>(),
		enums: new Set.create<CXType>(),
		macroDefinitions: new List<string>{},
		macroDefinitionsSet: new Set.create<string>(),
		rules: rules,
		ruleLookup: buildRuleLookup(rules),
	}	

	cursor := clang_getTranslationUnitCursor(unit)
	clang_visitChildren(cursor, pointer_cast(discoveryPass, pointer), pointer_cast(state, pointer))

	finalSourceText := getFinalSourceText(sourceText, state)
	unit = parseCFile(args.sourcePath, finalSourceText, clangArgs)
	numDiagnostics = clang_getNumDiagnostics(unit)
	generatedConstFirstLine := countLines(sourceText) + 1

	if numDiagnostics > 0 {
		Stderr.writeLine(format("clang temp source file compilation failed:"))
		
		for i := 0_u; i < numDiagnostics {
			diag := clang_getDiagnostic(unit, i)
			Stderr.writeLine(diagnosticToString(diag))
			loc := convertLocation(clang_getDiagnosticLocation(diag))
			if loc.filename == args.sourcePath && loc.line >= generatedConstFirstLine {
				Stderr.writeLine(format("-> {}", state.macroDefinitions[loc.line - generatedConstFirstLine]))
			}
		}
		exit(1)
	}

	state.output = new StringBuilder{}
	state.output.write(format("// Generated by ffigen {}\n", version))
	state.output.write(format("// Platform: {}\n", state.platform))
	state.output.write(format("// Target: {}\n", state.targetBits))
	
	state.validationOutput = new StringBuilder{}
	state.validationOutput.write(format("// Validation file generated by ffigen {}\n", version))
	state.validationOutput.write("#include <stddef.h>\n")
	state.validationOutput.write("#include <stdalign.h>\n")
	state.validationOutput.write("#ifdef _MSC_VER // for MSVC compatibility\n")
	state.validationOutput.write("#define alignof __alignof\n")
	state.validationOutput.write("#endif\n")
	state.validationOutput.write("_Static_assert(sizeof(_Bool) == 1, \"Validation error\");\n")

	cursor = clang_getTranslationUnitCursor(unit)
	clang_visitChildren(cursor, pointer_cast(generatePass, pointer), pointer_cast(state, pointer))

	for r in state.rules {
		if !r.matched {
			Stderr.writeLine(format("Warning: unmatched rule: {}", ruleToString(r)))
		}
	}	

	usedSymbols := Set.create<string>()
	duplicates := Set.create<string>()
	for e in state.symbols {
		sym := e.value
		if sym.done {
			assert(sym.muName != "")
			if !usedSymbols.tryAdd(sym.muName) {
				duplicates.tryAdd(sym.muName)
			}
		}
	}

	if duplicates.count > 0 {
		for it in duplicates {
			Stderr.writeLine(format("Warning: duplicate definition: {}", it))
		}
	}

	if !File.tryWriteString(args.outputPath, state.output.toString()) {
		Stderr.writeLine("Could not write output file")
		exit(1)
	}

	if args.validationPath != "" {
		if !File.tryWriteString(args.validationPath, state.validationOutput.toString()) {
			Stderr.writeLine("Could not write validation file")
			exit(1)
		}
	}

	Stderr.writeLine("Done")
}
